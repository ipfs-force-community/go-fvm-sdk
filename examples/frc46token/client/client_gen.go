// Code generated by github.com/ipfs-force-community/go-fvm-sdk. DO NOT EDIT.
package client

import (
	"bytes"
	context "context"
	"fmt"
	contract "frc46token/contract"

	address "github.com/filecoin-project/go-address"
	abi "github.com/filecoin-project/go-state-types/abi"
	big "github.com/filecoin-project/go-state-types/big"
	builtin "github.com/filecoin-project/go-state-types/builtin"
	init_ "github.com/filecoin-project/go-state-types/builtin/v9/init"
	actors "github.com/filecoin-project/venus/venus-shared/actors"
	blockstore "github.com/filecoin-project/venus/venus-shared/blockstore"
	types "github.com/filecoin-project/venus/venus-shared/types"
	"github.com/ipfs-force-community/go-fvm-sdk/sdk/adt"
	sdkTypes "github.com/ipfs-force-community/go-fvm-sdk/sdk/types"
	blocks "github.com/ipfs/go-block-format"
	cid "github.com/ipfs/go-cid"
	cbornode "github.com/ipfs/go-ipld-cbor"

	v0 "github.com/filecoin-project/venus/venus-shared/api/chain/v0"
)

type FullNode interface {
	ChainReadObj(context.Context, cid.Cid) ([]byte, error)
	ChainHasObj(context.Context, cid.Cid) (bool, error)
	ChainPutObj(context.Context, blocks.Block) error

	MpoolPushMessage(ctx context.Context, msg *types.Message, spec *types.MessageSendSpec) (*types.SignedMessage, error)
	StateWaitMsg(ctx context.Context, cid cid.Cid, confidence uint64) (*types.MsgLookup, error)
}

type IFrc46TokenClient interface {
	Install(context.Context, []byte, ...SendOption) (*sdkTypes.InstallReturn, error)

	CreateActor(context.Context, cid.Cid, *contract.ConstructorReq, ...SendOption) (*init_.ExecReturn, error)

	GetName(context.Context, ...SendOption) (sdkTypes.CborString, error)

	GetSymbol(context.Context, ...SendOption) (sdkTypes.CborString, error)

	GetGranularity(context.Context, ...SendOption) (sdkTypes.CborUint, error)

	GetTotalSupply(context.Context, ...SendOption) (*big.Int, error)

	Mint(context.Context, *contract.MintParams, ...SendOption) (*contract.MintReturn, error)

	BalanceOf(context.Context, *address.Address, ...SendOption) (*big.Int, error)

	Allowance(context.Context, *contract.GetAllowanceParams, ...SendOption) (*big.Int, error)

	Transfer(context.Context, *contract.TransferParams, ...SendOption) (*contract.TransferReturn, error)

	TransferFrom(context.Context, *contract.TransferFromParams, ...SendOption) (*contract.TransferFromReturn, error)

	IncreaseAllowance(context.Context, *contract.IncreaseAllowanceParams, ...SendOption) (*big.Int, error)

	DecreaseAllowance(context.Context, *contract.DecreaseAllowanceParams, ...SendOption) (*big.Int, error)

	RevokeAllowance(context.Context, *contract.RevokeAllowanceParams, ...SendOption) (*big.Int, error)

	Burn(context.Context, *contract.BurnParams, ...SendOption) (*contract.BurnReturn, error)

	BurnFrom(context.Context, *contract.BurnFromParams, ...SendOption) (*contract.BurnFromReturn, error)
}

var _ IFrc46TokenClient = (*Frc46TokenClient)(nil)

type Frc46TokenClient struct {
	node v0.FullNode
	bs   cbornode.IpldStore
	cfg  ClientOption
}

// Option option func
type Option func(opt *ClientOption)
type SendOption func(opt *ClientOption)

// ClientOption option for set client config
type ClientOption struct {
	fromAddress address.Address
	actor       address.Address
	codeCid     cid.Cid
}

// SetFromAddressOpt used to set from address who send actor messages
func SetFromAddressOpt(fromAddress address.Address) Option {
	return func(opt *ClientOption) {
		opt.fromAddress = fromAddress
	}
}

// SetFromAddrSendOpt used to set from address who send actor messages
func SetFromAddrSendOpt(fromAddress address.Address) SendOption {
	return func(opt *ClientOption) {
		opt.fromAddress = fromAddress
	}
}

// SetActorOpt used to set actor address
func SetActorOpt(actor address.Address) Option {
	return func(opt *ClientOption) {
		opt.actor = actor
	}
}

// SetCodeCid used to set actor code cid
func SetCodeCid(codeCid cid.Cid) Option {
	return func(opt *ClientOption) {
		opt.codeCid = codeCid
	}
}

func NewFrc46TokenClient(fullNode v0.FullNode, opts ...Option) *Frc46TokenClient {
	cfg := ClientOption{}
	for _, opt := range opts {
		opt(&cfg)
	}
	apiBlockStore := blockstore.NewAPIBlockstore(fullNode)
	cstore := cbornode.NewCborStore(apiBlockStore)
	return &Frc46TokenClient{
		node: fullNode,
		cfg:  cfg,
		bs:   cstore,
	}
}

func (c *Frc46TokenClient) ChangeFromAddress(addr address.Address) {
	c.cfg.fromAddress = addr
}

func (c *Frc46TokenClient) Install(ctx context.Context, code []byte, opts ...SendOption) (*sdkTypes.InstallReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	params, aerr := actors.SerializeParams(&sdkTypes.InstallParams{
		Code: code,
	})
	if aerr != nil {
		return nil, fmt.Errorf("failed to serialize params: %w", aerr)
	}

	msg := &types.Message{
		To:     builtin.InitActorAddr,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: 4,
		Params: params,
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor installation failed")
	}

	var result sdkTypes.InstallReturn
	r := bytes.NewReader(wait.Receipt.Return)
	if err := result.UnmarshalCBOR(r); err != nil {
		return nil, fmt.Errorf("error unmarshaling return value: %w", err)
	}
	c.cfg.codeCid = result.CodeCid
	return &result, nil
}
func (c *Frc46TokenClient) CreateActor(ctx context.Context, codeCid cid.Cid, ctorReq *contract.ConstructorReq, opts ...SendOption) (*init_.ExecReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	buf := bytes.NewBufferString("")
	if err := ctorReq.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	params, aErr := actors.SerializeParams(&init_.ExecParams{
		CodeCID:           codeCid,
		ConstructorParams: buf.Bytes(),
	})

	if aErr != nil {
		return nil, fmt.Errorf("failed to serialize params: %w", aErr)
	}

	msg := &types.Message{
		To:     builtin.InitActorAddr,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: 2,
		Params: params,
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}

	var result init_.ExecReturn
	r := bytes.NewReader(wait.Receipt.Return)
	if err := result.UnmarshalCBOR(r); err != nil {
		return nil, fmt.Errorf("error unmarshaling return value: %w", err)
	}
	c.cfg.actor = result.IDAddress
	return &result, nil
}

func (c *Frc46TokenClient) GetName(ctx context.Context, opts ...SendOption) (sdkTypes.CborString, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return "", fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return "", err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return "", err
	}

	return actState.GetName(ctx), nil
}

func (c *Frc46TokenClient) GetSymbol(ctx context.Context, opts ...SendOption) (sdkTypes.CborString, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return "", fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return "", err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return "", err
	}

	return actState.GetSymbol(ctx), nil
}

func (c *Frc46TokenClient) GetGranularity(ctx context.Context, opts ...SendOption) (sdkTypes.CborUint, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return 0, fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return 0, err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return 0, err
	}

	return actState.GetGranularity(ctx), nil
}

func (c *Frc46TokenClient) GetTotalSupply(ctx context.Context, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return nil, err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return nil, err
	}

	return actState.GetTotalSupply(ctx), nil
}

func (c *Frc46TokenClient) Mint(ctx context.Context, p0 *contract.MintParams, opts ...SendOption) (*contract.MintReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0x6f84ab2),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(contract.MintReturn)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) BalanceOf(ctx context.Context, p0 *address.Address, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return nil, err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return nil, err
	}

	return actState.BalanceOf(ctx, p0)
}

func (c *Frc46TokenClient) Allowance(ctx context.Context, p0 *contract.GetAllowanceParams, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}
	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("unset actor address for call")
	}

	act, err := c.node.StateGetActor(ctx, cfg_copy.actor, types.EmptyTSK)
	if err != nil {
		return nil, err
	}

	adtStore := adt.AdtStore(ctx)
	actState := contract.Frc46Token{}
	err = adtStore.Get(ctx, act.Head, &actState)
	if err != nil {
		return nil, err
	}

	return actState.Allowance(ctx, p0)
}

func (c *Frc46TokenClient) Transfer(ctx context.Context, p0 *contract.TransferParams, opts ...SendOption) (*contract.TransferReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0x4cbf732),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(contract.TransferReturn)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) TransferFrom(ctx context.Context, p0 *contract.TransferFromParams, opts ...SendOption) (*contract.TransferFromReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0xd7d4deed),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(contract.TransferFromReturn)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) IncreaseAllowance(ctx context.Context, p0 *contract.IncreaseAllowanceParams, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0x69ecb918),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(big.Int)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) DecreaseAllowance(ctx context.Context, p0 *contract.DecreaseAllowanceParams, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0x5b286f21),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(big.Int)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) RevokeAllowance(ctx context.Context, p0 *contract.RevokeAllowanceParams, opts ...SendOption) (*big.Int, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0xa4d840b1),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(big.Int)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) Burn(ctx context.Context, p0 *contract.BurnParams, opts ...SendOption) (*contract.BurnReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0x5584159a),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(contract.BurnReturn)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}

func (c *Frc46TokenClient) BurnFrom(ctx context.Context, p0 *contract.BurnFromParams, opts ...SendOption) (*contract.BurnFromReturn, error) {
	cfg_copy := c.cfg
	for _, opt := range opts {
		opt(&cfg_copy)
	}

	if c.cfg.actor == address.Undef {
		return nil, fmt.Errorf("need config actor address for call")
	}

	buf := bytes.NewBufferString("")
	if err := p0.MarshalCBOR(buf); err != nil {
		return nil, err
	}
	msg := &types.Message{
		To:     cfg_copy.actor,
		From:   cfg_copy.fromAddress,
		Value:  big.Zero(),
		Method: abi.MethodNum(0xb19a37a2),
		Params: buf.Bytes(),
	}

	smsg, err := c.node.MpoolPushMessage(ctx, msg, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to push message: %w", err)
	}

	wait, err := c.node.StateWaitMsg(ctx, smsg.Cid(), 0)
	if err != nil {
		return nil, fmt.Errorf("error waiting for message: %w", err)
	}

	// check it executed successfully
	if wait.Receipt.ExitCode != 0 {
		return nil, fmt.Errorf("actor execution failed")
	}
	if len(wait.Receipt.Return) == 0 {
		return nil, fmt.Errorf("expect get result for call")
	}

	result := new(contract.BurnFromReturn)
	result.UnmarshalCBOR(bytes.NewReader(wait.Receipt.Return))

	return result, nil

}
