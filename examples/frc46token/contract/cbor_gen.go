// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package contract

import (
	"fmt"
	"io"
	"math"
	"sort"

	abi "github.com/filecoin-project/go-state-types/abi"
	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

var lengthBufFrc46Token = []byte{134}

func (t *Frc46Token) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufFrc46Token); err != nil {
		return err
	}

	// t.Name (string) (string)
	if len(t.Name) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Name was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Name))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Name)); err != nil {
		return err
	}

	// t.Symbol (string) (string)
	if len(t.Symbol) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Symbol was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Symbol))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Symbol)); err != nil {
		return err
	}

	// t.Granularity (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Granularity)); err != nil {
		return err
	}

	// t.Supply (big.Int) (struct)
	if err := t.Supply.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Balances (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Balances); err != nil {
		return xerrors.Errorf("failed to write cid field t.Balances: %w", err)
	}

	// t.Allowances (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Allowances); err != nil {
		return xerrors.Errorf("failed to write cid field t.Allowances: %w", err)
	}

	return nil
}

func (t *Frc46Token) UnmarshalCBOR(r io.Reader) (err error) {
	*t = Frc46Token{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Name (string) (string)

	{
		sval, err := cbg.ReadString(cr)
		if err != nil {
			return err
		}

		t.Name = string(sval)
	}
	// t.Symbol (string) (string)

	{
		sval, err := cbg.ReadString(cr)
		if err != nil {
			return err
		}

		t.Symbol = string(sval)
	}
	// t.Granularity (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Granularity = uint64(extra)

	}
	// t.Supply (big.Int) (struct)

	{

		if err := t.Supply.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Supply: %w", err)
		}

	}
	// t.Balances (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Balances: %w", err)
		}

		t.Balances = c

	}
	// t.Allowances (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Allowances: %w", err)
		}

		t.Allowances = c

	}
	return nil
}

var lengthBufGetAllowanceParams = []byte{130}

func (t *GetAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufGetAllowanceParams); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *GetAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = GetAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	return nil
}

var lengthBufMintParams = []byte{131}

func (t *MintParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufMintParams); err != nil {
		return err
	}

	// t.InitialOwner (address.Address) (struct)
	if err := t.InitialOwner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData (types.RawBytes) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

func (t *MintParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = MintParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.InitialOwner (address.Address) (struct)

	{

		if err := t.InitialOwner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.InitialOwner: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufMintReturn = []byte{131}

func (t *MintReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufMintReturn); err != nil {
		return err
	}

	// t.Balances (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Supply (big.Int) (struct)
	if err := t.Supply.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RecipientData (types.RawBytes) (slice)
	if len(t.RecipientData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.RecipientData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.RecipientData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.RecipientData[:]); err != nil {
		return err
	}
	return nil
}

func (t *MintReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = MintReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balances (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balances: %w", err)
		}

	}
	// t.Supply (big.Int) (struct)

	{

		if err := t.Supply.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Supply: %w", err)
		}

	}
	// t.RecipientData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.RecipientData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.RecipientData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.RecipientData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufTransferParams = []byte{131}

func (t *TransferParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferParams); err != nil {
		return err
	}

	// t.To (address.Address) (struct)
	if err := t.To.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData (types.RawBytes) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

func (t *TransferParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.To (address.Address) (struct)

	{

		if err := t.To.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufTransferFromParams = []byte{132}

func (t *TransferFromParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferFromParams); err != nil {
		return err
	}

	// t.From (address.Address) (struct)
	if err := t.From.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.To (address.Address) (struct)
	if err := t.To.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData (types.RawBytes) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

func (t *TransferFromParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferFromParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.From (address.Address) (struct)

	{

		if err := t.From.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.From: %w", err)
		}

	}
	// t.To (address.Address) (struct)

	{

		if err := t.To.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufTransferFromReturn = []byte{132}

func (t *TransferFromReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTransferFromReturn); err != nil {
		return err
	}

	// t.FromBalance (big.Int) (struct)
	if err := t.FromBalance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.To_balance (big.Int) (struct)
	if err := t.To_balance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RecipientData (types.RawBytes) (slice)
	if len(t.RecipientData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.RecipientData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.RecipientData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.RecipientData[:]); err != nil {
		return err
	}
	return nil
}

func (t *TransferFromReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TransferFromReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.FromBalance (big.Int) (struct)

	{

		if err := t.FromBalance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.FromBalance: %w", err)
		}

	}
	// t.To_balance (big.Int) (struct)

	{

		if err := t.To_balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.To_balance: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	// t.RecipientData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.RecipientData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.RecipientData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.RecipientData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufIncreaseAllowanceParams = []byte{130}

func (t *IncreaseAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufIncreaseAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Increase (big.Int) (struct)
	if err := t.Increase.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *IncreaseAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = IncreaseAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	// t.Increase (big.Int) (struct)

	{

		if err := t.Increase.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Increase: %w", err)
		}

	}
	return nil
}

var lengthBufDecreaseAllowanceParams = []byte{130}

func (t *DecreaseAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDecreaseAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Decrease (big.Int) (struct)
	if err := t.Decrease.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *DecreaseAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DecreaseAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	// t.Decrease (big.Int) (struct)

	{

		if err := t.Decrease.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Decrease: %w", err)
		}

	}
	return nil
}

var lengthBufRevokeAllowanceParams = []byte{129}

func (t *RevokeAllowanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufRevokeAllowanceParams); err != nil {
		return err
	}

	// t.Operator (address.Address) (struct)
	if err := t.Operator.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *RevokeAllowanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = RevokeAllowanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Operator (address.Address) (struct)

	{

		if err := t.Operator.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Operator: %w", err)
		}

	}
	return nil
}

var lengthBufBurnParams = []byte{129}

func (t *BurnParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnParams); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufBurnReturn = []byte{129}

func (t *BurnReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnReturn); err != nil {
		return err
	}

	// t.Balances (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balances (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balances: %w", err)
		}

	}
	return nil
}

var lengthBufBurnFromParams = []byte{130}

func (t *BurnFromParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnFromParams); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnFromParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnFromParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufBurnFromReturn = []byte{130}

func (t *BurnFromReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufBurnFromReturn); err != nil {
		return err
	}

	// t.Balances (big.Int) (struct)
	if err := t.Balance.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Allowance (big.Int) (struct)
	if err := t.Allowance.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *BurnFromReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = BurnFromReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Balances (big.Int) (struct)

	{

		if err := t.Balance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Balances: %w", err)
		}

	}
	// t.Allowance (big.Int) (struct)

	{

		if err := t.Allowance.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Allowance: %w", err)
		}

	}
	return nil
}

var lengthBufConstructorReq = []byte{132}

func (t *ConstructorReq) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufConstructorReq); err != nil {
		return err
	}

	// t.Name (string) (string)
	if len(t.Name) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Name was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Name))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Name)); err != nil {
		return err
	}

	// t.Symbol (string) (string)
	if len(t.Symbol) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.Symbol was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajTextString, uint64(len(t.Symbol))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.Symbol)); err != nil {
		return err
	}

	// t.Granularity (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Granularity)); err != nil {
		return err
	}

	// t.Supply (big.Int) (struct)
	if err := t.Supply.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *ConstructorReq) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ConstructorReq{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Name (string) (string)

	{
		sval, err := cbg.ReadString(cr)
		if err != nil {
			return err
		}

		t.Name = string(sval)
	}
	// t.Symbol (string) (string)

	{
		sval, err := cbg.ReadString(cr)
		if err != nil {
			return err
		}

		t.Symbol = string(sval)
	}
	// t.Granularity (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Granularity = uint64(extra)

	}
	// t.Supply (big.Int) (struct)

	{

		if err := t.Supply.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Supply: %w", err)
		}

	}
	return nil
}

var lengthBufFRC46TokenReceived = []byte{134}

func (t *FRC46TokenReceived) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufFRC46TokenReceived); err != nil {
		return err
	}

	// t.From (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.From)); err != nil {
		return err
	}

	// t.To (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.To)); err != nil {
		return err
	}

	// t.Operator (abi.ActorID) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Operator)); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.OperatorData (types.RawBytes) (slice)
	if len(t.OperatorData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.OperatorData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.OperatorData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.OperatorData[:]); err != nil {
		return err
	}

	// t.TokenData (types.RawBytes) (slice)
	if len(t.TokenData) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.TokenData was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.TokenData))); err != nil {
		return err
	}

	if _, err := cw.Write(t.TokenData[:]); err != nil {
		return err
	}
	return nil
}

func (t *FRC46TokenReceived) UnmarshalCBOR(r io.Reader) (err error) {
	*t = FRC46TokenReceived{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.From (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.From = abi.ActorID(extra)

	}
	// t.To (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.To = abi.ActorID(extra)

	}
	// t.Operator (abi.ActorID) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Operator = abi.ActorID(extra)

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	// t.OperatorData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.OperatorData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.OperatorData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.OperatorData[:]); err != nil {
		return err
	}
	// t.TokenData (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.TokenData: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.TokenData = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.TokenData[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufUniversalReceiverParams = []byte{130}

func (t *UniversalReceiverParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufUniversalReceiverParams); err != nil {
		return err
	}

	// t.Type_ (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Type_)); err != nil {
		return err
	}

	// t.Payload (types.RawBytes) (slice)
	if len(t.Payload) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.Payload was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.Payload))); err != nil {
		return err
	}

	if _, err := cw.Write(t.Payload[:]); err != nil {
		return err
	}
	return nil
}

func (t *UniversalReceiverParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = UniversalReceiverParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Type_ (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Type_ = uint64(extra)

	}
	// t.Payload (types.RawBytes) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.Payload: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.Payload = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.Payload[:]); err != nil {
		return err
	}
	return nil
}
